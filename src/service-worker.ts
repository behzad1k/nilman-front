/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, NavigationRoute, setDefaultHandler } from 'workbox-routing';
import { StaleWhileRevalidate, NetworkFirst, CacheFirst, NetworkOnly } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';
import { APP_VERSION } from './config/app-version';

declare const self: ServiceWorkerGlobalScope;

// Claim clients immediately
clientsClaim();

// Clean up outdated caches
cleanupOutdatedCaches();

// Precache all of the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }
    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }
    // Skip bank callback URLs
    if (url.pathname.includes('payment/verify') || url.search.includes('payment/verify')) {
      return false;
    }
    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (fileExtensionRegexp.test(url.pathname)) {
      return false;
    }
    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Cache images with a cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: `images-${APP_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache CSS and JavaScript files with a stale-while-revalidate strategy
registerRoute(
  ({ request }) =>
    request.destination === 'style' ||
    request.destination === 'script',
  new StaleWhileRevalidate({
    cacheName: `static-resources-${APP_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: `google-fonts-stylesheets-${APP_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache the underlying font files with a cache-first strategy
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: `google-fonts-webfonts-${APP_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        maxEntries: 30,
      }),
    ],
  })
);

// IMPORTANT: Disable caching for ALL API calls by using NetworkOnly strategy
registerRoute(
  ({ url }) => url.hostname.includes('api'),
  new NetworkOnly()
);

// Handle bank callbacks with network-only strategy
registerRoute(
  ({ url }) => url.pathname.includes('payment/verify') || url.search.includes('payment/verify'),
  new NetworkOnly()
);

// Background sync for failed POST requests
const bgSyncPlugin = new BackgroundSyncPlugin('post-requests-queue', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 hours (in minutes)
});

// Handle POST requests with background sync
registerRoute(
  ({ url }) => url.hostname.includes('api') && url.pathname.includes('/submit'),
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  }),
  'POST'
);

// Default handler for everything else
setDefaultHandler(
  new StaleWhileRevalidate({
    cacheName: `default-${APP_VERSION}`,
  })
);

// Reload the page when the service worker is updated
self.addEventListener('controllerchange', () => {
  window.location.reload();
});

// Add custom cache invalidation logic
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Log when a new service worker is activated
self.addEventListener('activate', (event) => {
  console.log('Service worker activated with version:', APP_VERSION);
});

// Notify clients when an update is ready
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'CHECK_VERSION') {
    const clientVersion = event.data.version;
    // Check if we have message ports (MessageChannel was used)
    if (event.ports && event.ports[0]) {
      // Send response through the port
      event.ports[0].postMessage({
        type: 'UPDATE_AVAILABLE',
        isUpdateAvailable: clientVersion !== APP_VERSION,
        currentVersion: APP_VERSION,
        clientVersion: clientVersion
      });
    }
  }
});
